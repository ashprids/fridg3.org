<h1>toast | discord bot</h1>
<h2>a discord bot providing 24/7 radio in the fridg3.org discord server</h2>

<style>
/* Discord fonts */
@font-face {
	font-family: 'GG Sans';
	src: url('gg-sans-regular.ttf') format('truetype');
	font-weight: normal;
}

@font-face {
	font-family: 'GG Sans';
	src: url('gg-sans-bold.ttf') format('truetype');
	font-weight: bold;
}

/* Profile card â€” updated to match site theme */
.profile-card {
	display: flex;
	gap: 14px;
	align-items: center;
	max-width: 720px;
	background: rgba(255,255,255,0.02);
	border: 1px solid var(--border);
	padding: 16px;
	border-radius: 6px;
	margin-top: 18px;
	font-family: 'GG Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
	color: var(--fg);
}
.profile-avatar {
	width: 88px;
	height: 88px;
	border-radius: 8px;
	flex: 0 0 88px;
	overflow: hidden;
	background: #0a0a0a;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	border: 1px solid #222;
}
.profile-avatar img { width:100%; height:100%; object-fit:cover; display:block; }
.profile-meta { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 3px; }
.profile-name { font-size: 15px; font-family: 'GG Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-weight: bold; margin: 0; color: var(--fg); line-height: 1.2; }
.profile-username { color: var(--subtle); margin: 0; font-size: 12px; line-height: 1.2; }
.status-line { display: flex; align-items: center; gap: 6px; margin: 0; font-size: 12px; }
.status-dot { width: 8px; height: 8px; border-radius: 50%; background: #6ccf6c; box-shadow: 0 0 0 4px rgba(108,207,108,0.03); flex-shrink: 0; }
.now-playing { font-size: 12px; color: var(--fg); background: #0b0b0b; border: 1px solid #222; padding: 5px 6px; border-radius: 4px; line-height: 1.3; }
.muted { color: var(--subtle); opacity: 0.95; }

/* Hide seek/download controls when live-stream class is present */
.live-stream #mini-player-seek,
.live-stream #mini-player-download { display: none !important; }

@media (max-width:520px) {
	.profile-card { flex-direction:row; gap:12px; }
	.profile-meta { font-size:14px; }
}

/* Status updates grid */
.status-grid {
	display: grid;
	grid-template-columns: 180px 1fr;
	gap: 0;
	border: 1px solid var(--border);
	border-radius: 6px;
	overflow: hidden;
	font-size: 13px;
	max-width: 720px;
}

.status-grid-header {
	background: rgba(255,255,255,0.05);
	padding: 8px 12px;
	font-family: 'MainBold', monospace;
	color: var(--fg);
	border-bottom: 1px solid var(--border);
	border-right: 1px solid var(--border);
}

.status-grid-header:last-child {
	border-right: none;
}

.status-grid-row {
	padding: 8px 12px;
	border-bottom: 1px solid #1a1a1a;
	border-right: 1px solid #1a1a1a;
	color: var(--fg);
	word-break: break-word;
}

.status-grid-row:last-child {
	border-bottom: none;
}

.status-grid-row.time {
	color: var(--subtle);
	font-size: 12px;
	border-right: 1px solid var(--border);
}

.status-grid-row.status {
	border-right: none;
}

/* Match site theme for control panel inputs and button */
#stream-url-input,
#stream-name-input {
	width: 100%;
	height: 32px;
	font-family: 'MainRegular', monospace;
	font-size: 14px;
	padding: 8px;
	box-sizing: border-box;
	border: 1px solid var(--border);
	background-color: var(--bg);
	color: var(--fg);
	border-radius: 3px;
}

#stream-url-input:focus,
#stream-name-input:focus {
	outline: none;
	border-color: rgb(77, 118, 201);
}

#update-stream-button {
	display: block;
	padding: 8px 16px;
	border: 1px solid var(--border);
	background-color: var(--bg);
	color: var(--fg);
	font-family: 'MainRegular', monospace;
	font-size: 14px;
	cursor: pointer;
	transition: background-color 0.2s;
	box-sizing: border-box;
	width: 100%;
	margin-bottom: 16px;
	border-radius: 3px;
}

#update-stream-button:hover {
	background-color: rgb(30, 30, 30);
}

#update-stream-button:disabled {
	opacity: 0.65;
	cursor: not-allowed;
}

</style>
<br>
<div class="profile-card">
	<div class="profile-avatar" aria-hidden="true">
		<img src="https://images-ext-1.discordapp.net/external/S3f2i3R92rowfL9Uq5RmPFJtaqtluL-J7lVley9Ps7I/%3Fsize%3D4096/https/cdn.discordapp.com/avatars/1408177993284587794/2fd48df24ed679f3450b2532fce3f80b.png" alt="toast's avatar">
	</div>
	<div class="profile-meta">
		<div class="profile-name">toast</div>
		<div class="profile-username muted">@toast#9266</div>
		<div class="status-line">
			<div class="status-dot" title="online"></div>
			<div class="muted">Online</div>
		</div>
		<div class="now-playing">
      <span id="now-playing-name" class="muted">Loading...</span>
		</div>
	</div>
</div><br>
<button id="form-button" data-tooltip="open the current station in the web player">listen along</button>
<br>
<h3>status updates</h3><br>
<div class="status-grid" id="status-grid-container">
	<div class="status-grid-header time">time</div>
	<div class="status-grid-header status">status</div>
</div>

<br><br>
<div id="control-panel-container" style="display:none;">
	<h3>control panel</h3>
	<h5>for admin users only</h5><br>

	<input id="stream-url-input" type="text" placeholder="m3u stream URL" required><br><br>
	<input id="stream-name-input" type="text" placeholder="m3u stream name" required><br><br>
	<button id="update-stream-button" data-tooltip="update the m3u stream URL and restart playback">update m3u stream</button>

	<div id="stream-update-status" style="margin-top:12px; font-size:12px; display:none;"></div>
</div>

<script>
// Check if user is admin
async function checkAdminStatus() {
  try {
    const response = await fetch('/api/account/is-admin/');
    const data = await response.json();
    const isAdmin = data.isAdmin === true;
    
    // Show/hide control panel based on admin status
    const controlPanel = document.getElementById('control-panel-container');
    if (controlPanel) {
      controlPanel.style.display = isAdmin ? 'block' : 'none';
    }
    
    // Disable buttons if not admin
    const updateBtn = document.getElementById('update-stream-button');
    if (updateBtn) {
      updateBtn.disabled = !isAdmin;
      if (!isAdmin) {
        updateBtn.style.opacity = '0.5';
        updateBtn.style.cursor = 'not-allowed';
      }
    }
    
    return isAdmin;
  } catch (err) {
    console.error('Failed to check admin status:', err);
    // Hide control panel on error (assume not admin)
    const controlPanel = document.getElementById('control-panel-container');
    if (controlPanel) {
      controlPanel.style.display = 'none';
    }
    return false;
  }
}

// Check admin status on page load
checkAdminStatus();

// Default controls to non-live on load
setLiveControls(false);
// Fetch and display current station name and bot status
async function updateNowPlaying() {
  try {
    const response = await fetch('/api/discord-bot-status/');
    const data = await response.json();
    
    // Update bot status indicator
    const statusDot = document.querySelector('.status-dot');
    const statusText = document.querySelector('.status-line .muted');
    const nowPlayingEl = document.querySelector('.now-playing');
    const listenBtn = document.getElementById('form-button');
    
    if (data.bot && data.bot.status) {
      const isOnline = data.bot.status.toLowerCase() === 'online';
      
      if (isOnline) {
        statusDot.style.background = '#6ccf6c';
        statusText.textContent = 'Online';
        nowPlayingEl.style.display = 'block';
        if (listenBtn) listenBtn.style.display = '';
      } else {
        statusDot.style.background = '#cf6c6c';
        statusText.textContent = 'Offline';
        nowPlayingEl.style.display = 'none';
        if (listenBtn) listenBtn.style.display = 'none';
      }
    }
    
    // Update stream name
    if (data.stream && data.stream.name) {
      document.getElementById('now-playing-name').textContent = data.stream.name;
    }
    
    // Update status grid
    if (data.updates && Array.isArray(data.updates)) {
      updateStatusGrid(data.updates);
    }
  } catch (err) {
    console.error('Failed to fetch bot status:', err);
    // On error, show offline
    const statusDot = document.querySelector('.status-dot');
    const statusText = document.querySelector('.status-line .muted');
    const nowPlayingEl = document.querySelector('.now-playing');
    const listenBtn = document.getElementById('form-button');
    statusDot.style.background = '#cf6c6c';
    statusText.textContent = 'Offline';
    nowPlayingEl.style.display = 'none';
    if (listenBtn) listenBtn.style.display = 'none';
    document.getElementById('now-playing-name').textContent = 'Unknown';
  }
}

// Update status grid with new updates
function updateStatusGrid(updates) {
  const container = document.getElementById('status-grid-container');
  
  // Remove all rows except headers
  const rows = container.querySelectorAll('.status-grid-row');
  rows.forEach(row => row.remove());
  
  // Add new rows from updates
  updates.forEach(update => {
    const timeRow = document.createElement('div');
    timeRow.className = 'status-grid-row time';
    timeRow.textContent = update.time;
    container.appendChild(timeRow);
    
    const statusRow = document.createElement('div');
    statusRow.className = 'status-grid-row status';
    statusRow.textContent = update.status;
    container.appendChild(statusRow);
  });
}

// Toggle seek/download visibility for live streams
function setLiveControls(isLive) {
  const miniPlayerEl = document.getElementById('mini-player');
  const seekEl = document.getElementById('mini-player-seek');
  const downloadBtn = document.getElementById('mini-player-download');
  if (miniPlayerEl) miniPlayerEl.classList.toggle('live-stream', !!isLive);
  if (seekEl) seekEl.style.display = isLive ? 'none' : '';
  if (downloadBtn) downloadBtn.style.display = isLive ? 'none' : '';
}
// Normalize raw host:port into http and resolve playlists
async function resolveStreamUrl(url) {
  if (!url) return null;

  const normalize = (u) => {
    if (!u) return u;
    const trimmed = u.trim();
    if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(trimmed)) return trimmed;
    if (trimmed.startsWith('//')) return 'http:' + trimmed;
    // assume raw host:port -> base http
    return 'http://' + trimmed.replace(/\/$/, '');
  };

  const base = normalize(url);

  try {
    const resolveUrl = '/api/stream-proxy/?resolve=1&url=' + encodeURIComponent(base);
    const resp = await fetch(resolveUrl);
    const data = await resp.json();
    if (data && data.resolved) return data.resolved;
  } catch (err) {
    console.error('Failed to resolve playlist', err);
  }

  return base;
}

// Build a list of candidate stream URLs for raw host:port Shoutcast/Icecast
function buildStreamCandidates(resolvedUrl) {
  if (!resolvedUrl) return [];
  try {
    const urlObj = new URL(resolvedUrl, window.location.href);
    const path = urlObj.pathname || '/';
    const hasPath = path && path !== '/' && path !== '';

    // If there is already a path, just return the resolved URL
    if (hasPath) return [urlObj.toString()];

    // Otherwise, try common stream endpoints
    const origins = urlObj.origin;
    return [
      origins + '/;stream.nsv',
      origins + '/;?icy=http',
      origins + '/;stream.mp3',
      origins + '/;',
      origins + '/stream',
      origins + '/stream/',
      origins + '/live',
      origins + '/radio',
      origins + '/'
    ];
  } catch (_) {
    return [resolvedUrl];
  }
}

  // Play the current stream in the site mini player
  async function playCurrentStream() {
    try {
      const response = await fetch('/api/discord-bot-status/');
      const data = await response.json();

    const streamUrlRaw = data?.stream?.url;
      const streamName = data?.stream?.name || 'live stream';

    if (!streamUrlRaw) return;

      const audio = document.getElementById('mini-player-audio');
      if (!audio) {
        // Fallback: go to /music where the player lives
        window.location.href = '/music';
        return;
      }

    const resolved = await resolveStreamUrl(streamUrlRaw);
    if (!resolved) return;

    const candidates = buildStreamCandidates(resolved);
    if (!candidates.length) return;

    // Track toast stream sources for later detection
    window.__toastStreamCandidates = candidates.slice();

    const proxyCandidates = candidates.map(c => '/api/stream-proxy/?url=' + encodeURIComponent(c));

      // Update title display
      const titleEl = document.getElementById('mini-player-title-inner');
      if (titleEl) {
        titleEl.textContent = streamName;
      }

      // Set cover art for the stream
      const artEl = document.getElementById('mini-player-art');
      const streamArt = 'https://images-ext-1.discordapp.net/external/S3f2i3R92rowfL9Uq5RmPFJtaqtluL-J7lVley9Ps7I/%3Fsize%3D4096/https/cdn.discordapp.com/avatars/1408177993284587794/2fd48df24ed679f3450b2532fce3f80b.png';
      if (artEl) {
        artEl.src = streamArt;
      }

      // Mark as live stream (hide seek/download)
      setLiveControls(true);

      // Try candidates sequentially on error
      let currentIndex = 0;
      const tryPlay = (idx) => {
        if (idx >= proxyCandidates.length) return;
        audio.src = proxyCandidates[idx];
        audio.play().catch(() => {});
      };

      const onError = () => {
        currentIndex += 1;
        if (currentIndex < proxyCandidates.length) {
          tryPlay(currentIndex);
        }
      };

      audio.removeEventListener('error', onError);
      audio.addEventListener('error', onError, { once: true });
      tryPlay(0);

      // Update play icon to pause state
      const playIcon = document.querySelector('#mini-player-play i');
      if (playIcon) {
        playIcon.classList.remove('fa-play');
        playIcon.classList.add('fa-pause');
      }

      // Persist minimal state so refresh keeps playing
      try {
        const state = {
          src: audio.src,
          currentTime: 0,
          paused: false,
          volume: audio.volume,
          muted: audio.muted,
          title: titleEl ? titleEl.textContent : '',
          art: streamArt
        };
        window.localStorage.setItem('miniPlayerStateV1', JSON.stringify(state));
      } catch (_) { /* no-op */ }
    } catch (err) {
      console.error('Failed to start listen-along:', err);
    }
  }


// Update on page load and every 5 seconds
updateNowPlaying();

  // Listen along button wiring
  const listenBtn = document.getElementById('form-button');
  if (listenBtn) {
    listenBtn.addEventListener('click', (e) => {
      e.preventDefault();
      playCurrentStream();
    });
  }
setInterval(updateNowPlaying, 5000);

// Restore controls when non-toast audio plays
const miniAudio = document.getElementById('mini-player-audio');
if (miniAudio) {
  miniAudio.addEventListener('play', () => {
    const src = miniAudio.currentSrc || miniAudio.src || '';
    const candidates = (window.__toastStreamCandidates || []).map(c => c.split('?')[0]);
    const isToast = candidates.some(c => src.startsWith(c));
    setLiveControls(isToast);
  });
}

// Control panel script
const urlInput = document.getElementById('stream-url-input');

        // Hide seek/download for live stream and mark player as live
        const miniPlayerEl = document.getElementById('mini-player');
        const seekEl = document.getElementById('mini-player-seek');
        const downloadBtn = document.getElementById('mini-player-download');
        if (miniPlayerEl) miniPlayerEl.classList.add('live-stream');
        if (seekEl) seekEl.style.display = 'none';
        if (downloadBtn) downloadBtn.style.display = 'none';
const nameInput = document.getElementById('stream-name-input');
const updateBtn = document.getElementById('update-stream-button');
const statusDiv = document.getElementById('stream-update-status');

function showStatus(msg, isError = false) {
  statusDiv.textContent = msg;
  statusDiv.style.color = isError ? '#cf6c6c' : '#6ccf6c';
  statusDiv.style.display = 'block';
}

updateBtn.addEventListener('click', async function() {
  const url = urlInput.value.trim();
  const name = nameInput.value.trim();
  
  // Check admin status before allowing update
  const isAdmin = await checkAdminStatus();
  if (!isAdmin) {
    showStatus('You do not have permission to update the stream', true);
    return;
  }
  
  if (!url || !name) {
    showStatus('Please fill in both URL and name', true);
    return;
  }
  
  updateBtn.disabled = true;
  showStatus('Updating stream...');
  
  try {
    const response = await fetch('/api/discord-bot-control/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url, name })
    });
    
    const data = await response.json();
    
    if (response.ok && data.ok) {
      showStatus('Stream updated and bot restarted!');
      urlInput.value = '';
      nameInput.value = '';
      // Update now playing display
      updateNowPlaying();
      setTimeout(() => location.reload(), 1500);
    } else {
      showStatus(data.error || 'Failed to update stream', true);
    }
  } catch (err) {
    showStatus('Error: ' + err.message, true);
  } finally {
    updateBtn.disabled = false;
  }
});
</script>