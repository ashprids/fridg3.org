<h1>toast | discord bot</h1>
<h2>a discord bot providing 24/7 radio in the fridg3.org discord server</h2>

<style>
/* Discord fonts */
@font-face {
	font-family: 'GG Sans';
	src: url('gg-sans-regular.ttf') format('truetype');
	font-weight: normal;
}

@font-face {
	font-family: 'GG Sans';
	src: url('gg-sans-bold.ttf') format('truetype');
	font-weight: bold;
}

/* Profile card â€” updated to match site theme */
.profile-card {
	display: flex;
	gap: 14px;
	align-items: center;
	max-width: 720px;
	background: rgba(255,255,255,0.02);
	border: 1px solid var(--border);
	padding: 16px;
	border-radius: 6px;
	margin-top: 18px;
	font-family: 'GG Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
	color: var(--fg);
}
.profile-avatar {
	width: 88px;
	height: 88px;
	border-radius: 8px;
	flex: 0 0 88px;
	overflow: hidden;
	background: #0a0a0a;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	border: 1px solid #222;
}
.profile-avatar img { width:100%; height:100%; object-fit:cover; display:block; }
.profile-meta { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 3px; }
.profile-name { font-size: 15px; font-family: 'GG Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-weight: bold; margin: 0; color: var(--fg); line-height: 1.2; }
.profile-username { color: var(--subtle); margin: 0; font-size: 12px; line-height: 1.2; }
.status-line { display: flex; align-items: center; gap: 6px; margin: 0; font-size: 12px; }
.status-dot { width: 8px; height: 8px; border-radius: 50%; background: #6ccf6c; box-shadow: 0 0 0 4px rgba(108,207,108,0.03); flex-shrink: 0; }
.now-playing { font-size: 12px; color: var(--fg); background: #0b0b0b; border: 1px solid #222; padding: 5px 6px; border-radius: 4px; line-height: 1.3; }
.muted { color: var(--subtle); opacity: 0.95; }

/* Hide seek/download controls when live-stream class is present */
.live-stream #mini-player-seek,
.live-stream #mini-player-download { display: none !important; }

@media (max-width:520px) {
	.profile-card { flex-direction:row; gap:12px; }
	.profile-meta { font-size:14px; }
}

/* Match site theme for control panel inputs and button */
#stream-url-input,
#stream-name-input {
	width: 100%;
	height: 32px;
	font-family: 'MainRegular', monospace;
	font-size: 14px;
	padding: 8px;
	box-sizing: border-box;
	border: 1px solid var(--border);
	background-color: var(--bg);
	color: var(--fg);
	border-radius: 3px;
}

#stream-url-input:focus,
#stream-name-input:focus {
	outline: none;
	border-color: rgb(77, 118, 201);
}

#update-stream-button {
	display: block;
	padding: 8px 16px;
	border: 1px solid var(--border);
	background-color: var(--bg);
	color: var(--fg);
	font-family: 'MainRegular', monospace;
	font-size: 14px;
	cursor: pointer;
	transition: background-color 0.2s;
	box-sizing: border-box;
	width: 100%;
	margin-bottom: 16px;
	border-radius: 3px;
}

#update-stream-button:hover {
	background-color: rgb(30, 30, 30);
}

#update-stream-button:disabled {
	opacity: 0.65;
	cursor: not-allowed;
}

#listen-along-button {
  display: inline-block;
  padding: 8px 16px;
  border: 1px solid var(--border);
  background-color: var(--bg);
  color: var(--fg);
  font-family: 'MainRegular', monospace;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.2s;
  box-sizing: border-box;
  border-radius: 3px;
}

#listen-along-button:hover {
  background-color: rgb(30, 30, 30);
}

</style>
<br>
<div class="profile-card">
	<div class="profile-avatar" aria-hidden="true">
		<img src="https://images-ext-1.discordapp.net/external/S3f2i3R92rowfL9Uq5RmPFJtaqtluL-J7lVley9Ps7I/%3Fsize%3D4096/https/cdn.discordapp.com/avatars/1408177993284587794/2fd48df24ed679f3450b2532fce3f80b.png" alt="toast's avatar">
	</div>
	<div class="profile-meta">
		<div class="profile-name">toast</div>
		<div class="profile-username muted">@toast#9266</div>
		<div class="status-line">
			<div class="status-dot" title="online"></div>
			<div class="muted">Online</div>
		</div>
		<div class="now-playing">
      <span id="now-playing-name" class="muted">Loading...</span>
		</div>
	</div>
</div><br>
<button id="listen-along-button" data-tooltip="open the current station in the web player">listen along</button>
<br>
<br><br>
<div id="control-panel-container" style="display:none;">
	<h3>control panel</h3>
	<h5>for admin users only</h5><br>

  <label style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
    <input id="status-toggle" type="checkbox" style="width:16px; height:16px;">
    <span>show toast as online</span>
  </label>

	<input id="stream-url-input" type="text" placeholder="m3u stream URL" required><br><br>
	<input id="stream-name-input" type="text" placeholder="m3u stream name" required><br><br>
	<button id="update-stream-button" data-tooltip="update the m3u stream URL and restart playback">update m3u stream</button>
    <h5>HTTPS streams are recommended. Non-HTTPS streams need to be proxied through the webserver, which substantially increases server load.</h5>
	<div id="stream-update-status" style="margin-top:12px; font-size:12px; display:none;"></div>
</div>

<script>
// Manual online status toggle (admin-only control)
const statusToggle = document.getElementById('status-toggle');
const statusDot = document.querySelector('.status-dot');
const statusText = document.querySelector('.status-line .muted');
const nowPlayingEl = document.querySelector('.now-playing');
const listenBtn = document.getElementById('listen-along-button');

function applyManualStatus(isOnline) {
  if (statusDot) statusDot.style.background = isOnline ? '#6ccf6c' : '#cf6c6c';
  if (statusText) statusText.textContent = isOnline ? 'Online' : 'Offline';
  if (nowPlayingEl) nowPlayingEl.style.display = isOnline ? 'block' : 'none';
  if (listenBtn) listenBtn.style.display = isOnline ? '' : 'none';
}

function setStatusUI(isOnline) {
  if (statusToggle) statusToggle.checked = !!isOnline;
  applyManualStatus(!!isOnline);
}

async function persistStatus(isOnline) {
  if (!statusToggle) return;
  statusToggle.disabled = true;
  showStatus(`Setting status to ${isOnline ? 'online' : 'offline'}...`);
  try {
    const response = await fetch('/api/discord-bot-control/status/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ status: isOnline ? 'online' : 'offline' })
    });
    const data = await response.json();
    if (!response.ok || data.ok !== true) {
      throw new Error(data.error || 'Failed to update status');
    }
    showStatus(`Status set to ${isOnline ? 'online' : 'offline'}.`);
  } catch (err) {
    showStatus(err.message, true);
    setStatusUI(!isOnline);
  } finally {
    statusToggle.disabled = false;
  }
}

if (statusToggle) {
  statusToggle.addEventListener('change', () => {
    const isOnline = !!statusToggle.checked;
    setStatusUI(isOnline);
    persistStatus(isOnline);
  });
}

// Default to offline until server value arrives
setStatusUI(false);

// Check if user is admin
async function checkAdminStatus() {
  try {
    const response = await fetch('/api/account/is-admin/');
    const data = await response.json();
    const isAdmin = data.isAdmin === true;
    
    // Show/hide control panel based on admin status
    const controlPanel = document.getElementById('control-panel-container');
    if (controlPanel) {
      controlPanel.style.display = isAdmin ? 'block' : 'none';
    }

    const statusToggleEl = document.getElementById('status-toggle');
    if (statusToggleEl) {
      statusToggleEl.disabled = !isAdmin;
    }
    
    // Disable buttons if not admin
    const updateBtn = document.getElementById('update-stream-button');
    if (updateBtn) {
      updateBtn.disabled = !isAdmin;
      if (!isAdmin) {
        updateBtn.style.opacity = '0.5';
        updateBtn.style.cursor = 'not-allowed';
      }
    }
    
    return isAdmin;
  } catch (err) {
    console.error('Failed to check admin status:', err);
    // Hide control panel on error (assume not admin)
    const controlPanel = document.getElementById('control-panel-container');
    if (controlPanel) {
      controlPanel.style.display = 'none';
    }
    return false;
  }
}

// Check admin status on page load
checkAdminStatus();

// Default controls to non-live on load
setLiveControls(false);
// Fetch and display current station name + status from shared config
async function updateNowPlaying() {
  try {
    const response = await fetch('/api/discord-bot-status/');
    const data = await response.json();

    const streamName = (data.stream && data.stream.name) ? data.stream.name : null;
    const nowPlayingName = document.getElementById('now-playing-name');
    if (nowPlayingName) {
      nowPlayingName.textContent = streamName ? `Listening to ${streamName}` : 'Unknown';
    }

    const isOnline = (data.bot && data.bot.status)
      ? String(data.bot.status).toLowerCase() === 'online'
      : false;
    setStatusUI(isOnline);
  } catch (err) {
    console.error('Failed to fetch bot status:', err);
    const nowPlayingName = document.getElementById('now-playing-name');
    if (nowPlayingName) nowPlayingName.textContent = 'Unknown';
    setStatusUI(false);
  }
}

// Toggle seek/download visibility for live streams
function setLiveControls(isLive) {
  const miniPlayerEl = document.getElementById('mini-player');
  const seekEl = document.getElementById('mini-player-seek');
  const downloadBtn = document.getElementById('mini-player-download');
  if (miniPlayerEl) miniPlayerEl.classList.toggle('live-stream', !!isLive);
  if (seekEl) seekEl.style.display = isLive ? 'none' : '';
  if (downloadBtn) downloadBtn.style.display = isLive ? 'none' : '';
}
// Normalize raw host:port into http and resolve playlists
async function resolveStreamUrl(url) {
  if (!url) return null;

  const normalize = (u) => {
    if (!u) return u;
    const trimmed = u.trim();
    if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(trimmed)) return trimmed;
    if (trimmed.startsWith('//')) return 'http:' + trimmed;
    // assume raw host:port -> base http
    return 'http://' + trimmed.replace(/\/$/, '');
  };

  const base = normalize(url);

  // If not a playlist, return base (we'll build candidates later)
  if (!/\.m3u8?$|\.pls$/i.test(base)) {
    return base;
  }

  try {
    const resp = await fetch(base);
    const text = await resp.text();

    // .pls support: lines like File1=http://...
    if (/\.pls$/i.test(base)) {
      const match = text.match(/File\d+\s*=\s*(.+)/i);
      if (match && match[1]) {
        return normalize(match[1]);
      }
    }

    // .m3u support: first non-comment line
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    for (const line of lines) {
      if (line.startsWith('#')) continue;
      return normalize(line);
    }
  } catch (err) {
    console.error('Failed to resolve playlist', err);
  }

  // Fallback
  return base;
}

// Build a list of candidate stream URLs for raw host:port Shoutcast/Icecast
function buildStreamCandidates(resolvedUrl) {
  if (!resolvedUrl) return [];
  try {
    const urlObj = new URL(resolvedUrl, window.location.href);
    const path = urlObj.pathname || '/';
    const hasPath = path && path !== '/' && path !== '';

    // If there is already a path, just return the resolved URL
    if (hasPath) return [urlObj.toString()];

    // Otherwise, try common stream endpoints
    const origins = urlObj.origin;
    return [
      origins + '/;stream.nsv',
      origins + '/;?icy=http',
      origins + '/;stream.mp3',
      origins + '/;',
      origins + '/stream',
      origins + '/stream/',
      origins + '/live',
      origins + '/radio',
      origins + '/'
    ];
  } catch (_) {
    return [resolvedUrl];
  }
}

  // Play the current stream in the site mini player
  async function playCurrentStream() {
    try {
      const response = await fetch('/api/discord-bot-status/');
      const data = await response.json();

    const streamUrlRaw = data?.stream?.url;
      const streamName = data?.stream?.name || 'live stream';

    if (!streamUrlRaw) return;

      const audio = document.getElementById('mini-player-audio');
      if (!audio) {
        // Fallback: go to /music where the player lives
        window.location.href = '/music';
        return;
      }

    const resolved = await resolveStreamUrl(streamUrlRaw);
    if (!resolved) return;

    const rawCandidates = buildStreamCandidates(resolved);
    if (!rawCandidates.length) return;

    const candidates = rawCandidates
      .map((u) => buildProxyUrl(u))
      .filter(Boolean);
    if (!candidates.length) return;

    // Track toast stream sources for later detection
    window.__toastStreamCandidates = candidates.slice();

      // Update title display
      const titleEl = document.getElementById('mini-player-title-inner');
      if (titleEl) {
        titleEl.textContent = streamName;
      }

      // Set cover art for the stream
      const artEl = document.getElementById('mini-player-art');
      const streamArt = 'https://images-ext-1.discordapp.net/external/S3f2i3R92rowfL9Uq5RmPFJtaqtluL-J7lVley9Ps7I/%3Fsize%3D4096/https/cdn.discordapp.com/avatars/1408177993284587794/2fd48df24ed679f3450b2532fce3f80b.png';
      if (artEl) {
        artEl.src = streamArt;
      }

      // Mark as live stream (hide seek/download)
      setLiveControls(true);

      // Try candidates sequentially on error
      let currentIndex = 0;
      const tryPlay = (idx) => {
        if (idx >= candidates.length) return;
        audio.src = candidates[idx];
        audio.play().catch(() => {});
      };

      const onError = () => {
        currentIndex += 1;
        if (currentIndex < candidates.length) {
          tryPlay(currentIndex);
        }
      };

      audio.removeEventListener('error', onError);
      audio.addEventListener('error', onError, { once: true });
      tryPlay(0);

      // Update play icon to pause state
      const playIcon = document.querySelector('#mini-player-play i');
      if (playIcon) {
        playIcon.classList.remove('fa-play');
        playIcon.classList.add('fa-pause');
      }

      // Persist minimal state so refresh keeps playing
      try {
        const state = {
          src: audio.src,
          currentTime: 0,
          paused: false,
          volume: audio.volume,
          muted: audio.muted,
          title: titleEl ? titleEl.textContent : '',
          art: streamArt
        };
        window.localStorage.setItem('miniPlayerStateV1', JSON.stringify(state));
      } catch (_) { /* no-op */ }
    } catch (err) {
      console.error('Failed to start listen-along:', err);
    }
  }


// Update on page load and every 5 seconds
updateNowPlaying();

  // Listen along button wiring
  if (listenBtn) {
    listenBtn.addEventListener('click', (e) => {
      e.preventDefault();
      playCurrentStream();
    });
  }
setInterval(updateNowPlaying, 5000);

// Restore controls when non-toast audio plays
const miniAudio = document.getElementById('mini-player-audio');
if (miniAudio) {
  miniAudio.addEventListener('play', () => {
    const src = miniAudio.currentSrc || miniAudio.src || '';
    const candidates = (window.__toastStreamCandidates || []).map((c) => {
      try {
        return new URL(c, window.location.origin).toString().split('?')[0];
      } catch (_) {
        return (c || '').split('?')[0];
      }
    });
    const isToast = candidates.some(c => c && src.startsWith(c));
    setLiveControls(isToast);
  });
}

function buildProxyUrl(targetUrl) {
  if (!targetUrl) return null;
  try {
    const parsed = new URL(targetUrl, window.location.href);
    if (!/^https?:$/.test(parsed.protocol)) return null;
    return '/api/stream-proxy/?u=' + encodeURIComponent(parsed.toString());
  } catch (_) {
    return null;
  }
}

// Control panel script
const urlInput = document.getElementById('stream-url-input');

        // Hide seek/download for live stream and mark player as live
        const miniPlayerEl = document.getElementById('mini-player');
        const seekEl = document.getElementById('mini-player-seek');
        const downloadBtn = document.getElementById('mini-player-download');
        if (miniPlayerEl) miniPlayerEl.classList.add('live-stream');
        if (seekEl) seekEl.style.display = 'none';
        if (downloadBtn) downloadBtn.style.display = 'none';
const nameInput = document.getElementById('stream-name-input');
const updateBtn = document.getElementById('update-stream-button');
const statusDiv = document.getElementById('stream-update-status');

function showStatus(msg, isError = false) {
  statusDiv.textContent = msg;
  statusDiv.style.color = isError ? '#cf6c6c' : '#6ccf6c';
  statusDiv.style.display = 'block';
}

updateBtn.addEventListener('click', async function() {
  const url = urlInput.value.trim();
  const name = nameInput.value.trim();
  
  // Check admin status before allowing update
  const isAdmin = await checkAdminStatus();
  if (!isAdmin) {
    showStatus('You do not have permission to update the stream', true);
    return;
  }
  
  if (!url || !name) {
    showStatus('Please fill in both URL and name', true);
    return;
  }
  
  updateBtn.disabled = true;
  showStatus('Updating stream...');
  
  try {
    const response = await fetch('/api/discord-bot-control/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url, name })
    });
    
    const data = await response.json();
    
    if (response.ok && data.ok) {
      showStatus('Stream updated and bot restarted!');
      urlInput.value = '';
      nameInput.value = '';
      // Update now playing display
      updateNowPlaying();
      setTimeout(() => location.reload(), 1500);
    } else {
      showStatus(data.error || 'Failed to update stream', true);
    }
  } catch (err) {
    showStatus('Error: ' + err.message, true);
  } finally {
    updateBtn.disabled = false;
  }
});
</script>